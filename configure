#!/bin/sh

# Find out where configure is (in what dir)
ROOT_DIR="`dirname $0`"
ROOT_DIR="`cd $ROOT_DIR && pwd`"

PWD="`pwd`"
PREFIX="`pwd`/bin"

. $ROOT_DIR/config.lib

# Set default dirs
OBJS_DIR="$PWD/objs"
BASE_SRC_OBJS_DIR="$OBJS_DIR"
LANG_OBJS_DIR="$OBJS_DIR/lang"
BIN_DIR="$PREFIX"
SRC_DIR="$ROOT_DIR/src"
LANG_DIR="$SRC_DIR/lang"
MEDIA_DIR="$ROOT_DIR/media"
SOURCE_LIST="$ROOT_DIR/source.list"

if [ "$1" = "--reconfig" ]
then
	if ! [ -f "config.cache" ]
	then
		echo "can't reconfigure, because never configured before"
		exit 1
	fi
	# Make sure we don't lock config.cache
	configure=`cat config.cache`
	$configure
	exit $?
fi

set_default
detect_params "$@"
save_params
check_params
make_cflags_and_ldflags

EXE=""
if [ "$os" = "MINGW" ] || [ "$os" = "CYGWIN" ] || [ "$os" = "OS2" ]
then
	EXE=".exe"
fi

TTD="openttd$EXE"
STRGEN="strgen$EXE"
ENDIAN_CHECK="endian_check$EXE"

if [ -z "$sort" ]
then
	PIPE_SORT="sed s/a/a/"
else
	PIPE_SORT="$sort"
fi

if ! [ -f "$LANG_DIR/english.txt" ]
then
	echo "Languages not found in $LANG_DIR. Can't continue without it."
	echo "Please make sure the dir exists and contains at least english.txt"
fi

# Read the source.list and process it
SRCS="`cat $ROOT_DIR/source.list | tr '\r' '\n' | awk '
	{  }
	/^(	*)#end/  { if (deep == skip) { skip -= 1; } deep -= 1; next; }
	/^(	*)#else/ { if (deep == skip) { skip -= 1; } else if (deep - 1 == skip) { skip += 1; } next; }
	/^(	*)#if/   {
		gsub("	", "", $0);
		gsub("^#if ", "", $0);

		if (deep != skip) { deep += 1; next; }

		deep += 1;

		if ($0 == "SDL"         && "'$sdl_config'" == "")          { next; }
		if ($0 == "OSX"         && "'$os'" != "OSX")               { next; }
		if ($0 == "DEDICATED"   && "'$enable_dedicated'" != "1")   { next; }
		if ($0 == "COCOA"       && "'$with_cocoa'" == "0")         { next; }
		if ($0 == "BEOS"        && "'$os'" != "BEOS")              { next; }
		if ($0 == "WIN32"       && "'$os'" != "MINGW" &&
		                "'$os'" != "CYGWIN" && "'$os'" != "MSVC" ) { next; }
		if ($0 == "MSVC"        && "'$os'" != "MSVC")              { next; }
		if ($0 == "DIRECTMUSIC" && "'$with_direct_music'" == "0")  { next; }

		skip += 1;

		next;
	}
	/^(	*)#/ { next }
	/^$/ { next }
	/\.h$/ { next }
	/\.hpp$/ { next }
	{
		if (deep == skip) {
			gsub("	", "", $0);
			print $0;
		}
	}
' | $PIPE_SORT`"

OBJS_C="`  echo \"$SRCS\" | awk ' { ORS = " " } /\.c$/   { gsub(".c$",   ".o", $0); print $0; }'`"
OBJS_CPP="`echo \"$SRCS\" | awk ' { ORS = " " } /\.cpp$/ { gsub(".cpp$", ".o", $0); print $0; }'`"
OBJS_M="`  echo \"$SRCS\" | awk ' { ORS = " " } /\.m$/   { gsub(".m$",   ".o", $0); print $0; }'`"
OBJS_RC="` echo \"$SRCS\" | awk ' { ORS = " " } /\.rc$/  { gsub(".rc$",  ".o", $0); print $0; }'`"
SRCS="`    echo \"$SRCS\" | awk ' { ORS = " " } { print $0; }'`"

# In makefiles, we always use -u for sort
if [ -z "$sort" ]
then
	sort="sed s/a/a/"
else
	sort="$sort -u"
fi

CONFIGURE_FILES="$ROOT_DIR/configure $ROOT_DIR/config.lib $ROOT_DIR/Makefile.in $ROOT_DIR/Makefile.lang.in $ROOT_DIR/Makefile.src.in"

generate_main
generate_lang
generate_src
